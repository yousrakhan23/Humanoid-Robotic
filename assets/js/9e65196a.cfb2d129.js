"use strict";(globalThis.webpackChunkphysical_ai_book_frontend=globalThis.webpackChunkphysical_ai_book_frontend||[]).push([[9751],{5498(e,n,o){o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>a,toc:()=>r});const a=JSON.parse('{"id":"robotics-module-one/chapter-4/lesson-2","title":"ROS 2 Actions","description":"Understanding and implementing goal-oriented communication with ROS 2 Actions.","source":"@site/docs/robotics-module-one/chapter-4/lesson-2.md","sourceDirName":"robotics-module-one/chapter-4","slug":"/robotics-module-one/chapter-4/lesson-2","permalink":"/docs/robotics-module-one/chapter-4/lesson-2","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/robotics-module-one/chapter-4/lesson-2.md","tags":[],"version":"current","frontMatter":{"title":"ROS 2 Actions","description":"Understanding and implementing goal-oriented communication with ROS 2 Actions."},"sidebar":"roboticsModuleSidebar","previous":{"title":"ROS 2 Parameters","permalink":"/docs/robotics-module-one/chapter-4/lesson-1"},"next":{"title":"ROS 2 Launch Files","permalink":"/docs/robotics-module-one/chapter-4/lesson-3"}}');var t=o(4848),s=o(8453);const i={title:"ROS 2 Actions",description:"Understanding and implementing goal-oriented communication with ROS 2 Actions."},l="ROS 2 Actions",c={},r=[{value:"Introduction",id:"introduction",level:2},{value:"Actions Overview",id:"actions-overview",level:2},{value:"Action Message Types",id:"action-message-types",level:2},{value:"Defining Action Messages",id:"defining-action-messages",level:2},{value:"Action Server Implementation",id:"action-server-implementation",level:2},{value:"Basic Action Server",id:"basic-action-server",level:3},{value:"Advanced Action Server with Robot Navigation",id:"advanced-action-server-with-robot-navigation",level:3},{value:"Action Client Implementation",id:"action-client-implementation",level:2},{value:"Basic Action Client",id:"basic-action-client",level:3},{value:"Advanced Action Client",id:"advanced-action-client",level:3},{value:"Action Command-Line Tools",id:"action-command-line-tools",level:2},{value:"Using ros2 action Command",id:"using-ros2-action-command",level:3},{value:"Action Best Practices",id:"action-best-practices",level:2},{value:"1. Proper Error Handling",id:"1-proper-error-handling",level:3},{value:"2. Resource Management",id:"2-resource-management",level:3},{value:"3. Appropriate Use Cases",id:"3-appropriate-use-cases",level:3},{value:"Integration with Navigation Systems",id:"integration-with-navigation-systems",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ros-2-actions",children:"ROS 2 Actions"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 Actions provide a goal-oriented communication pattern that extends beyond the simple request-response of services or the asynchronous nature of topics. Actions are ideal for long-running tasks that may take time to complete, provide feedback during execution, and can be preempted or cancelled. This lesson explores the structure, implementation, and use cases for ROS 2 Actions."}),"\n",(0,t.jsx)(n.h2,{id:"actions-overview",children:"Actions Overview"}),"\n",(0,t.jsx)(n.p,{children:"Actions combine the features of services and topics to provide:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal requests"}),": Similar to service requests but for long-running tasks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"}),": Continuous updates during task execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result reporting"}),": Final outcome when the task completes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cancel capability"}),": Ability to interrupt ongoing tasks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preemption"}),": Ability to replace ongoing tasks with new ones"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"action-message-types",children:"Action Message Types"}),"\n",(0,t.jsx)(n.p,{children:"Each action definition creates three message types:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal"})," (",(0,t.jsx)(n.code,{children:"action_name.action"}),"): Defines the goal message structure"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"})," (",(0,t.jsx)(n.code,{children:"action_name.action"}),"): Provides ongoing feedback during execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result"})," (",(0,t.jsx)(n.code,{children:"action_name.action"}),"): Contains the final result when complete"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"defining-action-messages",children:"Defining Action Messages"}),"\n",(0,t.jsxs)(n.p,{children:["Action definitions use a special ",(0,t.jsx)(n.code,{children:".action"})," file format:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# NavigateToPose.action\n\n# Goal definition\ngeometry_msgs/PoseStamped pose\nstring behavior_tree\n\n---\n# Result definition\nbool reached_pose\n\n---\n# Feedback definition\ngeometry_msgs/PoseStamped current_pose\nstring message\nfloat32 distance_remaining\n"})}),"\n",(0,t.jsx)(n.p,{children:"This single file creates three message types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"NavigateToPose_Goal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"NavigateToPose_Result"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"NavigateToPose_Feedback"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"action-server-implementation",children:"Action Server Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-action-server",children:"Basic Action Server"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci  # Built-in example\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        \n        # Create action server\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback\n        )\n    \n    def destroy_node(self):\n        self._action_server.destroy()\n        super().destroy_node()\n    \n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject goal requests\"\"\"\n        self.get_logger().info('Received goal request')\n        # Accept all goals for this example\n        return GoalResponse.ACCEPT\n    \n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject cancel requests\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n    \n    async def execute_callback(self, goal_handle):\n        \"\"\"Execute the goal - this runs in a separate thread\"\"\"\n        self.get_logger().info('Executing goal...')\n        \n        # Get the goal order\n        order = goal_handle.request.order\n        \n        # Create feedback message\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n        \n        # Simulate computation with feedback\n        for i in range(1, order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n            \n            if not goal_handle.is_active:\n                self.get_logger().info('Goal aborted')\n                return Fibonacci.Result()\n            \n            # Calculate next Fibonacci number\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1]\n            )\n            \n            # Publish feedback\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\n            \n            # Sleep to simulate work\n            from time import sleep\n            sleep(0.5)\n        \n        # Goal completed successfully\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f'Goal succeeded with result: {result.sequence}')\n        \n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_server = FibonacciActionServer()\n    \n    try:\n        rclpy.spin(action_server)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        action_server.destroy_node()\n        rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-action-server-with-robot-navigation",children:"Advanced Action Server with Robot Navigation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped\nfrom nav2_msgs.action import NavigateToPose  # Hypothetical navigation action\nimport threading\nimport time\n\nclass NavigationActionServer(Node):\n    def __init__(self):\n        super().__init__('navigation_action_server')\n        \n        # Create callback group for thread safety\n        callback_group = ReentrantCallbackGroup()\n        \n        # Action server\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            execute_callback=self.execute_callback,\n            callback_group=callback_group\n        )\n        \n        # Publishers and subscribers\n        self.pose_sub = self.create_subscription(\n            PoseWithCovarianceStamped,\n            'amcl_pose',\n            self.pose_callback,\n            10,\n            callback_group=callback_group\n        )\n        \n        self.cmd_pub = self.create_publisher(\n            Twist,\n            'cmd_vel',\n            10,\n            callback_group=callback_group\n        )\n        \n        # Store current robot pose\n        self.current_pose = None\n        self.current_pose_lock = threading.RLock()\n    \n    def pose_callback(self, msg):\n        \"\"\"Update current robot pose\"\"\"\n        with self.current_pose_lock:\n            self.current_pose = msg.pose.pose\n    \n    def calculate_distance(self, pose1, pose2):\n        \"\"\"Calculate Euclidean distance between two poses\"\"\"\n        dx = pose1.position.x - pose2.position.x\n        dy = pose1.position.y - pose2.position.y\n        return (dx*dx + dy*dy) ** 0.5\n    \n    async def execute_callback(self, goal_handle):\n        \"\"\"Execute navigation goal\"\"\"\n        goal = goal_handle.request.pose\n        \n        self.get_logger().info(f'Navigating to pose: ({goal.pose.position.x}, {goal.pose.position.y})')\n        \n        # Create feedback message\n        feedback_msg = NavigateToPose.Feedback()\n        \n        # Navigation loop\n        while rclpy.ok():\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Navigation canceled')\n                return NavigateToPose.Result()\n            \n            if not goal_handle.is_active:\n                self.get_logger().info('Navigation aborted')\n                return NavigateToPose.Result()\n            \n            # Get current pose for feedback\n            with self.current_pose_lock:\n                if self.current_pose is None:\n                    continue\n                current = self.current_pose\n            \n            # Calculate distance to goal\n            distance = self.calculate_distance(current, goal.pose)\n            \n            # Check if reached\n            if distance < 0.2:  # 20cm threshold\n                goal_handle.succeed()\n                result = NavigateToPose.Result()\n                result.reached_pose = True\n                self.get_logger().info('Navigation completed successfully')\n                return result\n            \n            # Provide feedback\n            feedback_msg.current_pose.pose = current\n            feedback_msg.distance_remaining = distance\n            feedback_msg.message = f'Navigating, {distance:.2f}m remaining'\n            \n            goal_handle.publish_feedback(feedback_msg)\n            \n            # Generate navigation command (simplified)\n            cmd = Twist()\n            cmd.linear.x = min(0.5, distance)  # Approach speed based on distance\n            cmd.angular.z = 0.5 * math.atan2(\n                goal.pose.position.y - current.position.y,\n                goal.pose.position.x - current.position.x\n            )\n            self.cmd_pub.publish(cmd)\n            \n            # Wait before next iteration\n            time.sleep(0.1)\n        \n        # If we get here, something went wrong\n        goal_handle.abort()\n        result = NavigateToPose.Result()\n        result.reached_pose = False\n        return result\n"})}),"\n",(0,t.jsx)(n.h2,{id:"action-client-implementation",children:"Action Client Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-action-client",children:"Basic Action Client"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionClient(Node):\n    def __init__(self):\n        super().__init__(\'fibonacci_action_client\')\n        \n        # Create action client\n        self._action_client = ActionClient(\n            self,\n            Fibonacci,\n            \'fibonacci\'\n        )\n    \n    def send_goal(self, order):\n        """Send goal to action server"""\n        # Wait for action server\n        self._action_client.wait_for_server()\n        \n        # Create goal message\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n        \n        # Send goal with callbacks\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n        \n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n    \n    def goal_response_callback(self, future):\n        """Handle goal response"""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Goal rejected\')\n            return\n        \n        self.get_logger().info(\'Goal accepted\')\n        \n        # Request result\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.result_callback)\n    \n    def feedback_callback(self, feedback_msg):\n        """Handle feedback during execution"""\n        self.get_logger().info(f\'Received feedback: {feedback_msg.feedback.sequence}\')\n    \n    def result_callback(self, future):\n        """Handle final result"""\n        result = future.result().result\n        self.get_logger().info(f\'Result: {result.sequence}\')\n        \n        # Shutdown after receiving result\n        rclpy.shutdown()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    \n    action_client = FibonacciActionClient()\n    \n    # Send goal\n    action_client.send_goal(10)\n    \n    # Spin to process callbacks\n    try:\n        rclpy.spin(action_client)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        action_client.destroy_node()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-action-client",children:"Advanced Action Client"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom rclpy.duration import Duration\nfrom geometry_msgs.msg import PoseStamped\nfrom my_robot_msgs.action import MoveArm  # Hypothetical action\n\nclass AdvancedActionClient(Node):\n    def __init__(self):\n        super().__init__(\'advanced_action_client\')\n        \n        self._action_client = ActionClient(\n            self,\n            MoveArm,\n            \'move_arm\'\n        )\n    \n    def send_navigation_goal(self, target_pose):\n        """Send navigation goal with timeout and cancellation handling"""\n        self._action_client.wait_for_server()\n        \n        goal_msg = MoveArm.Goal()\n        goal_msg.target_pose = target_pose\n        goal_msg.allow_replanning = True\n        goal_msg.planning_attempts = 5\n        \n        # Send goal with feedback\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n        \n        # Set timeout for goal acceptance\n        timer = self.create_timer(5.0, self.timeout_callback)\n        \n        self._send_goal_future.add_done_callback(\n            lambda future: self.goal_response_callback(future, timer)\n        )\n    \n    def goal_response_callback(self, future, timer):\n        """Handle goal response with timer cancellation"""\n        timer.cancel()\n        \n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Goal rejected\')\n            return\n        \n        self.get_logger().info(\'Goal accepted, waiting for result\')\n        \n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.result_callback)\n    \n    def timeout_callback(self):\n        """Handle timeout waiting for goal acceptance"""\n        self.get_logger().info(\'Goal request timed out\')\n        rclpy.shutdown()\n    \n    def feedback_callback(self, feedback_msg):\n        """Handle feedback with additional processing"""\n        current_pose = feedback_msg.current_pose\n        distance = feedback_msg.distance_remaining\n        message = feedback_msg.message\n        \n        self.get_logger().info(\n            f\'Feedback: {message}, dist: {distance:.2f}m, \'\n            f\'pos: ({current_pose.pose.position.x:.2f}, {current_pose.pose.position.y:.2f})\'\n        )\n    \n    def result_callback(self, future):\n        """Handle result with error checking"""\n        goal_result = future.result()\n        result = goal_result.result\n        status = goal_result.status\n        \n        if status == GoalStatus.STATUS_SUCCEEDED:\n            self.get_logger().info(\'Action completed successfully\')\n        elif status == GoalStatus.STATUS_CANCELED:\n            self.get_logger().info(\'Action was canceled\')\n        elif status == GoalStatus.STATUS_ABORTED:\n            self.get_logger().info(\'Action was aborted\')\n        else:\n            self.get_logger().info(f\'Action failed with status: {status}\')\n        \n        # Process result based on success\n        if hasattr(result, \'reached_pose\') and result.reached_pose:\n            self.get_logger().info(\'Reached target pose successfully\')\n        else:\n            self.get_logger().info(\'Failed to reach target pose\')\n        \n        rclpy.shutdown()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"action-command-line-tools",children:"Action Command-Line Tools"}),"\n",(0,t.jsx)(n.h3,{id:"using-ros2-action-command",children:"Using ros2 action Command"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# List all actions\nros2 action list\n\n# Get action type information\nros2 action type /fibonacci\n\n# Send a goal from command line\nros2 action send_goal /fibonacci example_interfaces/action/Fibonacci "{order: 5}"\n\n# Send goal and stream feedback\nros2 action send_goal -f /fibonacci example_interfaces/action/Fibonacci "{order: 5}"\n\n# Get action information\nros2 action info /fibonacci\n'})}),"\n",(0,t.jsx)(n.h2,{id:"action-best-practices",children:"Action Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-proper-error-handling",children:"1. Proper Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"async def execute_callback(self, goal_handle):\n    try:\n        # Perform action\n        result = await self.perform_action(goal_handle.request)\n        \n        if goal_handle.is_cancel_requested:\n            goal_handle.canceled()\n            return MyAction.Result()\n        \n        goal_handle.succeed()\n        return result\n        \n    except Exception as e:\n        self.get_logger().error(f'Action failed: {e}')\n        goal_handle.abort()\n        return MyAction.Result()  # or appropriate error result\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-resource-management",children:"2. Resource Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def destroy_node(self):\n    """Properly clean up action server"""\n    if hasattr(self, \'_action_server\'):\n        self._action_server.destroy()\n    super().destroy_node()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-appropriate-use-cases",children:"3. Appropriate Use Cases"}),"\n",(0,t.jsx)(n.p,{children:"Use actions when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Long-running operations"}),": Tasks that take seconds to minutes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Progress feedback"}),": Need to report ongoing progress"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cancellable operations"}),": Tasks that can be interrupted"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preemptible goals"}),": Ability to replace current goal with new one"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Use topics/services instead when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Short operations"}),": Fast request-response patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Continuous data"}),": Streaming sensor information"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simple commands"}),": Toggle switches, configuration updates"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-navigation-systems",children:"Integration with Navigation Systems"}),"\n",(0,t.jsx)(n.p,{children:"Actions are particularly useful in navigation systems:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Navigation action client example\nclass NavigationClient(Node):\n    def __init__(self):\n        super().__init__(\'navigation_client\')\n        self.nav_client = ActionClient(self, NavigateToPose, \'navigate_to_pose\')\n    \n    def navigate_to(self, x, y, theta=0.0):\n        """Navigate to a specific pose"""\n        goal = NavigateToPose.Goal()\n        goal.pose = PoseStamped()\n        goal.pose.pose.position.x = x\n        goal.pose.pose.position.y = y\n        goal.pose.pose.orientation = self.yaw_to_quaternion(theta)\n        \n        # Send with feedback\n        future = self.nav_client.send_goal_async(\n            goal,\n            feedback_callback=self.nav_feedback\n        )\n        future.add_done_callback(self.nav_goal_response)\n    \n    def nav_feedback(self, feedback_msg):\n        """Handle navigation feedback"""\n        self.get_logger().info(f\'Navigating: {feedback_msg.feedback.message}\')\n'})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 Actions provide a powerful communication pattern for long-running, goal-oriented tasks that require feedback and cancellation capabilities. They're ideal for navigation, manipulation, and other complex robotic behaviors that unfold over time. Understanding when and how to use actions is crucial for developing robust robotic applications. In the next lesson, we'll explore ROS 2 Launch files for managing complex system configurations."})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,o){o.d(n,{R:()=>i,x:()=>l});var a=o(6540);const t={},s=a.createContext(t);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);